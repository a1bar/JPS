package parser;
 
import java.io.StringReader;
import java.util.ArrayList;
import java.util.List;

import java_cup.runtime.DefaultSymbolFactory;
import java_cup.runtime.Symbol;
import ast.*;
import ast.binary.*;
import ast.terminal.*;
import ast.unary.*;

parser code {: 
	public Lexer lexer;
	private String expr;
	public Expression RESULT;
	
	public CalcParser(String expr) {
		this.symbolFactory = new DefaultSymbolFactory();   
		this.expr = expr;
	}
	
	void setResult(Expression exp) {
		this.RESULT = exp;
	}  

:};

init with {: 	    lexer = new Lexer(new StringReader(expr)); :};
scan with {:		return lexer.next_token(); :};


terminal Integer INTEGER_LITERAL;
terminal Double DOUBLE_LITERAL;
terminal Boolean BOOLEAN_LITERAL;

terminal String WHERE;
terminal String JOIN;

terminal String FORALL;
terminal String FORANY;

terminal String NOT;

terminal String UNION;
terminal String IN;

terminal String ORDER_BY;
terminal String CLOSE_BY;

terminal String COMMA;

terminal String OR;
terminal String AND;

terminal String EQUALS;
terminal String NOT_EQUALS;
terminal String MORE;
terminal String LESS;
terminal String MORE_OR_EQUAL;
terminal String LESS_OR_EQUAL;

terminal String PLUS;
terminal String MINUS;

terminal String MULTIPLY; 
terminal String DIVIDE;
terminal String MODULO;

terminal String AS;
terminal String GROUP_AS;

terminal String SUM;
terminal String COUNT;
terminal String AVG;
terminal String MIN;
terminal String MAX;
terminal String UNIQUE;
terminal String EXISTS;
terminal String MINUS_FUNCTION;
terminal String INTERSECT;

terminal String DOT;

terminal String BAG;
terminal String SEQUENCE;
terminal String STRUCT;

terminal String LEFT_ROUND_BRACKET;
terminal String RIGHT_ROUND_BRACKET;

non terminal Expression goal;
non terminal Expression expr;


//priority

precedence left WHERE, JOIN; 
precedence left FORALL, FORANY; 
precedence left NOT; 
precedence left UNION, IN; 
precedence left ORDER_BY, CLOSE_BY; 
precedence left COMMA; 
precedence left OR, AND;
precedence left EQUALS, NOT_EQUALS, MORE, LESS, MORE_OR_EQUAL, LESS_OR_EQUAL;  
precedence left PLUS, MINUS; 
precedence left MULTIPLY, DIVIDE, MODULO; 
precedence left AS, GROUP_AS; 
precedence left SUM, COUNT, AVG, MIN, MAX, UNIQUE, EXISTS, MINUS_FUNCTION, INTERSECT; 
precedence left DOT; 
precedence left BAG, SEQUENCE, STRUCT; 
precedence left LEFT_ROUND_BRACKET, RIGHT_ROUND_BRACKET;

start with goal;

goal ::= expr:e		{: RESULT = e; parser.setResult(e); :} ;

expr  ::=
		expr:e1 PLUS:o expr:e2	{: RESULT = new PlusExpression(e1, e2); :}
	| 	expr:e1 MINUS:o expr:e2	{: RESULT = new MinusExpression(e1, e2); :}
	| 	expr:e1 MULTIPLY:o 	 expr:e2	{: RESULT = new MultiplyExpression(e1, e2); :}
	| 	expr:e1 DIVIDE:o	 expr:e2	{: RESULT = new DivideExpression(e1, e2); :}
	| 	INTEGER_LITERAL:o {: RESULT = new IntegerTerminal((Integer)o); :}
	|	LEFT_ROUND_BRACKET:o expr:e1 RIGHT_ROUND_BRACKET {: RESULT = e1; :}
	;